 # SQL

## Содержание
1. [Основы SQL](#основы-sql)
2. [Операции с данными](#операции-с-данными)
3. [Соединения таблиц](#соединения-таблиц)
4. [Агрегация](#агрегация)
5. [Оптимизация](#оптимизация)
6. [Транзакции](#транзакции)
7. [Нормализация](#нормализация)
8. [Репликация баз данных](#репликация-баз-данных)
9. [Вопросы на собеседовании](#вопросы-на-собеседовании)

## Основы SQL

### Создание таблицы
```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### Типы данных
- **Числовые**: INT, BIGINT, DECIMAL, FLOAT
- **Строковые**: VARCHAR, CHAR, TEXT
- **Дата и время**: DATE, TIME, TIMESTAMP
- **Булевы**: BOOLEAN
- **JSON**: JSON, JSONB

## Операции с данными

### SELECT
```sql
-- Базовый запрос
SELECT * FROM users;

-- С условием
SELECT name, email FROM users WHERE age > 18;

-- Сортировка
SELECT * FROM users ORDER BY created_at DESC;

-- Лимит
SELECT * FROM users LIMIT 10 OFFSET 20;
```

### INSERT
```sql
-- Одиночная вставка
INSERT INTO users (name, email) VALUES ('John', 'john@example.com');

-- Множественная вставка
INSERT INTO users (name, email) VALUES 
    ('John', 'john@example.com'),
    ('Jane', 'jane@example.com');
```

### UPDATE
```sql
UPDATE users 
SET name = 'John Doe', email = 'john.doe@example.com'
WHERE id = 1;
```

### DELETE
```sql
DELETE FROM users WHERE id = 1;
```

## Соединения таблиц

### Типы JOIN и их различия

#### INNER JOIN
- **Описание**: Возвращает только те строки, для которых есть совпадения в обеих таблицах.
- **Когда использовать**: Когда нужны только данные, имеющие соответствия в обеих таблицах.
- **Пример**:
```sql
SELECT users.name, orders.amount
FROM users
INNER JOIN orders ON users.id = orders.user_id;
```
- **Визуализация**:
```
Таблица A (users)    Таблица B (orders)    Результат (INNER JOIN)
--------------       ---------------       ---------------------
| id | name |       | id | user_id |      | name | amount |
|----|------|       |----|---------|      |------|--------|
| 1  | John |       | 1  | 1       |  =>  | John | 100    |
| 2  | Jane |       | 2  | 1       |      | John | 200    |
| 3  | Bob  |       | 3  | 2       |      | Jane | 150    |
                    | 4  | 4       |
```

#### LEFT JOIN (или LEFT OUTER JOIN)
- **Описание**: Возвращает все строки из левой таблицы и соответствующие строки из правой таблицы. Если совпадений нет, для правой таблицы возвращаются NULL.
- **Когда использовать**: Когда нужны все записи из первой таблицы, независимо от наличия соответствий во второй.
- **Пример**:
```sql
SELECT users.name, orders.amount
FROM users
LEFT JOIN orders ON users.id = orders.user_id;
```
- **Визуализация**:
```
Таблица A (users)    Таблица B (orders)    Результат (LEFT JOIN)
--------------       ---------------       -------------------
| id | name |       | id | user_id |      | name | amount |
|----|------|       |----|---------|      |------|--------|
| 1  | John |       | 1  | 1       |  =>  | John | 100    |
| 2  | Jane |       | 2  | 1       |      | John | 200    |
| 3  | Bob  |       | 3  | 2       |      | Jane | 150    |
                    | 4  | 4       |      | Bob  | NULL   |
```

#### RIGHT JOIN (или RIGHT OUTER JOIN)
- **Описание**: Возвращает все строки из правой таблицы и соответствующие строки из левой таблицы. Если совпадений нет, для левой таблицы возвращаются NULL.
- **Когда использовать**: Когда нужны все записи из второй таблицы, независимо от наличия соответствий в первой.
- **Пример**:
```sql
SELECT users.name, orders.amount
FROM users
RIGHT JOIN orders ON users.id = orders.user_id;
```
- **Визуализация**:
```
Таблица A (users)    Таблица B (orders)    Результат (RIGHT JOIN)
--------------       ---------------       --------------------
| id | name |       | id | user_id |      | name | amount |
|----|------|       |----|---------|      |------|--------|
| 1  | John |       | 1  | 1       |  =>  | John | 100    |
| 2  | Jane |       | 2  | 1       |      | John | 200    |
| 3  | Bob  |       | 3  | 2       |      | Jane | 150    |
                    | 4  | 4       |      | NULL | 300    |
```

#### FULL JOIN (или FULL OUTER JOIN)
- **Описание**: Возвращает все строки из обеих таблиц. Если совпадений нет, для соответствующей таблицы возвращаются NULL.
- **Когда использовать**: Когда нужны все записи из обеих таблиц, независимо от наличия соответствий.
- **Пример**:
```sql
SELECT users.name, orders.amount
FROM users
FULL JOIN orders ON users.id = orders.user_id;
```
- **Визуализация**:
```
Таблица A (users)    Таблица B (orders)    Результат (FULL JOIN)
--------------       ---------------       -------------------
| id | name |       | id | user_id |      | name | amount |
|----|------|       |----|---------|      |------|--------|
| 1  | John |       | 1  | 1       |  =>  | John | 100    |
| 2  | Jane |       | 2  | 1       |      | John | 200    |
| 3  | Bob  |       | 3  | 2       |      | Jane | 150    |
                    | 4  | 4       |      | Bob  | NULL   |
                                          | NULL | 300    |
```

#### CROSS JOIN
- **Описание**: Возвращает декартово произведение двух таблиц (каждая строка первой таблицы соединяется с каждой строкой второй таблицы).
- **Когда использовать**: Редко используется в реальных приложениях, но может быть полезен для генерации всех возможных комбинаций.
- **Пример**:
```sql
SELECT users.name, products.name
FROM users
CROSS JOIN products;
```
- **Визуализация**:
```
Таблица A (users)    Таблица B (products)    Результат (CROSS JOIN)
--------------       -----------------       ---------------------
| id | name |       | id | name     |       | name | name     |
|----|------|       |----|----------|       |------|----------|
| 1  | John |       | 1  | Phone    |   =>  | John | Phone    |
| 2  | Jane |       | 2  | Laptop   |       | John | Laptop   |
                                            | Jane | Phone    |
                                            | Jane | Laptop   |
```

#### SELF JOIN
- **Описание**: Соединение таблицы с самой собой. Используется, когда в таблице есть ссылки на записи в той же таблице.
- **Когда использовать**: Для иерархических данных, отношений типа "менеджер-подчиненный" и т.д.
- **Пример**:
```sql
SELECT e.name AS employee, m.name AS manager
FROM employees e
LEFT JOIN employees m ON e.manager_id = m.id;
```
- **Визуализация**:
```
Таблица employees                 Результат (SELF JOIN)
-----------------                 -------------------
| id | name  | manager_id |      | employee | manager |
|----|-------|------------|      |----------|---------|
| 1  | Alice | NULL       |  =>  | Alice    | NULL    |
| 2  | Bob   | 1          |      | Bob      | Alice   |
| 3  | Carol | 1          |      | Carol    | Alice   |
| 4  | Dave  | 2          |      | Dave     | Bob     |
```

### Поиск уникальных элементов по столбцу

Для поиска уникальных значений в столбце используется оператор `DISTINCT`:

```sql
-- Получение уникальных значений из одного столбца
SELECT DISTINCT status FROM orders;

-- Получение уникальных комбинаций значений из нескольких столбцов
SELECT DISTINCT user_id, status FROM orders;

-- Подсчет количества уникальных значений
SELECT COUNT(DISTINCT user_id) FROM orders;
```

Альтернативный способ с использованием GROUP BY:

```sql
-- Получение уникальных значений с дополнительной агрегацией
SELECT user_id, COUNT(*) as order_count
FROM orders
GROUP BY user_id;
```

Для поиска дубликатов:

```sql
-- Поиск дубликатов по email
SELECT email, COUNT(*) as count
FROM users
GROUP BY email
HAVING COUNT(*) > 1;
```

## Агрегация

### GROUP BY
```sql
SELECT 
    user_id,
    COUNT(*) as order_count,
    SUM(amount) as total_amount
FROM orders
GROUP BY user_id;
```

### HAVING
```sql
SELECT 
    user_id,
    COUNT(*) as order_count
FROM orders
GROUP BY user_id
HAVING COUNT(*) > 5;
```

### Оконные функции
```sql
SELECT 
    user_id,
    amount,
    ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY amount DESC) as rank
FROM orders;
```

## Оптимизация

### Мониторинг и оптимизация производительности PostgreSQL

#### Выявление медленных запросов

##### 1. Использование log_min_duration_statement

Это параметр конфигурации PostgreSQL, который позволяет логировать запросы, выполнение которых занимает больше указанного времени:

```sql
-- В postgresql.conf или через ALTER SYSTEM
ALTER SYSTEM SET log_min_duration_statement = '100ms';
-- Затем перезагрузить конфигурацию
SELECT pg_reload_conf();
```

- Значение указывается в миллисекундах
- Установка в 0 логирует все запросы
- Установка в -1 отключает логирование по времени выполнения

##### 2. Использование pg_stat_statements

Расширение, которое собирает статистику выполнения всех SQL-запросов:

```sql
-- Включение расширения
CREATE EXTENSION IF NOT EXISTS pg_stat_statements;

-- Настройка в postgresql.conf
-- shared_preload_libraries = 'pg_stat_statements'
-- pg_stat_statements.track = all

-- Просмотр самых медленных запросов
SELECT 
    query,
    calls,
    total_exec_time / calls as avg_time,
    min_exec_time,
    max_exec_time,
    stddev_exec_time,
    rows / calls as avg_rows
FROM pg_stat_statements
ORDER BY avg_time DESC
LIMIT 10;

-- Сброс статистики
SELECT pg_stat_statements_reset();
```

##### 3. Использование auto_explain

Модуль для автоматического логирования планов выполнения медленных запросов:

```sql
-- В postgresql.conf
-- shared_preload_libraries = 'auto_explain'
-- auto_explain.log_min_duration = '100ms'
-- auto_explain.log_analyze = true
-- auto_explain.log_verbose = true
-- auto_explain.log_buffers = true
-- auto_explain.log_nested_statements = true
```

##### 4. Анализ журналов PostgreSQL

Журналы PostgreSQL содержат информацию о медленных запросах, ошибках и других событиях:

```bash
# Просмотр последних записей журнала
tail -f /var/log/postgresql/postgresql-14-main.log

# Поиск медленных запросов
grep "duration:" /var/log/postgresql/postgresql-14-main.log
```

#### Оптимизация производительности PostgreSQL

##### 1. Настройка параметров конфигурации

```sql
-- Увеличение shared_buffers (обычно 25% от RAM)
ALTER SYSTEM SET shared_buffers = '2GB';

-- Настройка work_mem для сложных запросов
ALTER SYSTEM SET work_mem = '64MB';

-- Настройка maintenance_work_mem для обслуживания
ALTER SYSTEM SET maintenance_work_mem = '256MB';

-- Настройка effective_cache_size (обычно 50-75% от RAM)
ALTER SYSTEM SET effective_cache_size = '6GB';

-- Настройка параллельного выполнения запросов
ALTER SYSTEM SET max_parallel_workers_per_gather = 4;
ALTER SYSTEM SET max_parallel_workers = 8;

-- Применение изменений
SELECT pg_reload_conf();
```

##### 2. Регулярное обслуживание базы данных

```sql
-- VACUUM удаляет "мертвые" строки и обновляет статистику
VACUUM ANALYZE;

-- VACUUM FULL освобождает больше места, но блокирует таблицу
VACUUM FULL table_name;

-- Автоматический VACUUM (настройка в postgresql.conf)
-- autovacuum = on
-- autovacuum_vacuum_threshold = 50
-- autovacuum_analyze_threshold = 50
-- autovacuum_vacuum_scale_factor = 0.1
-- autovacuum_analyze_scale_factor = 0.05

-- Обновление статистики для оптимизатора запросов
ANALYZE table_name;
```

##### 3. Оптимизация запросов

```sql
-- Использование EXPLAIN ANALYZE для анализа плана запроса
EXPLAIN ANALYZE
SELECT * FROM large_table WHERE non_indexed_column = 'value';

-- Создание индексов для часто используемых условий
CREATE INDEX idx_table_column ON table_name(column_name);

-- Использование частичных индексов
CREATE INDEX idx_orders_status ON orders(status) WHERE status = 'processing';

-- Использование индексов для сортировки
CREATE INDEX idx_users_created_at ON users(created_at DESC);

-- Использование покрывающих индексов
CREATE INDEX idx_covering ON table_name(id, name, email);
```

##### 4. Партиционирование таблиц

```sql
-- Создание партиционированной таблицы по диапазону дат
CREATE TABLE logs (
    id SERIAL,
    log_time TIMESTAMP,
    message TEXT
) PARTITION BY RANGE (log_time);

-- Создание партиций
CREATE TABLE logs_2023_q1 PARTITION OF logs
    FOR VALUES FROM ('2023-01-01') TO ('2023-04-01');

CREATE TABLE logs_2023_q2 PARTITION OF logs
    FOR VALUES FROM ('2023-04-01') TO ('2023-07-01');
```

##### 5. Использование материализованных представлений

```sql
-- Создание материализованного представления
CREATE MATERIALIZED VIEW mv_monthly_sales AS
SELECT 
    date_trunc('month', order_date) as month,
    sum(amount) as total_sales
FROM orders
GROUP BY 1;

-- Обновление материализованного представления
REFRESH MATERIALIZED VIEW mv_monthly_sales;

-- Создание индекса для материализованного представления
CREATE INDEX idx_mv_monthly_sales_month ON mv_monthly_sales(month);
```

##### 6. Оптимизация соединений таблиц

```sql
-- Использование EXPLAIN для анализа JOIN
EXPLAIN ANALYZE
SELECT u.name, o.amount 
FROM users u 
JOIN orders o ON u.id = o.user_id;

-- Создание индексов для столбцов, участвующих в JOIN
CREATE INDEX idx_orders_user_id ON orders(user_id);

-- Использование JOIN LATERAL для оптимизации подзапросов
SELECT u.name, recent_orders.amount
FROM users u
LEFT JOIN LATERAL (
    SELECT amount 
    FROM orders 
    WHERE user_id = u.id 
    ORDER BY created_at DESC 
    LIMIT 3
) recent_orders ON true;
```

##### 7. Использование connection pooling

Использование PgBouncer или Pgpool-II для управления пулом соединений:

```bash
# Установка PgBouncer
apt-get install pgbouncer

# Настройка в pgbouncer.ini
[databases]
mydb = host=localhost port=5432 dbname=mydb

[pgbouncer]
listen_port = 6432
listen_addr = *
auth_type = md5
pool_mode = transaction
max_client_conn = 1000
default_pool_size = 20
```

##### 8. Оптимизация дисковой подсистемы

- Размещение WAL (Write-Ahead Log) на отдельном быстром диске
- Настройка параметров WAL для оптимизации производительности:

```sql
-- Настройка размера WAL сегментов
ALTER SYSTEM SET wal_buffers = '16MB';

-- Настройка контрольных точек
ALTER SYSTEM SET checkpoint_timeout = '15min';
ALTER SYSTEM SET checkpoint_completion_target = 0.9;
```

### Индексы

#### Что такое индексы
Индексы — это специальные структуры данных, которые улучшают скорость поиска и доступа к данным в таблицах базы данных. Они работают аналогично указателю в книге, позволяя быстро находить нужную информацию без необходимости просматривать всю таблицу.

#### Зачем нужны индексы
- Ускорение операций поиска и фильтрации (WHERE)
- Оптимизация сортировки (ORDER BY)
- Ускорение операций соединения таблиц (JOIN)
- Обеспечение уникальности данных (UNIQUE индексы)

#### Типы индексов и поддерживаемые типы данных

##### B-tree индексы
- **Описание**: Наиболее распространенный тип индексов, основанный на B-дереве (сбалансированном дереве)
- **Подходит для**: Равенства (=), диапазонов (>, <, BETWEEN), сортировки (ORDER BY), группировки (GROUP BY)
- **Типы данных**: Числовые, строковые, даты, булевы
- **Пример создания**:
```sql
CREATE INDEX idx_users_email ON users(email);
```

##### Hash индексы
- **Описание**: Используют хеш-функции для быстрого поиска по точному соответствию
- **Подходит для**: Только операций равенства (=)
- **Типы данных**: Любые типы данных, для которых можно вычислить хеш
- **Пример создания** (PostgreSQL):
```sql
CREATE INDEX idx_users_email_hash ON users USING HASH (email);
```

##### GIN (Generalized Inverted Index)
- **Описание**: Инвертированные индексы для сложных типов данных
- **Подходит для**: Массивов, JSON, полнотекстового поиска
- **Типы данных**: JSONB, массивы, tsvector (для полнотекстового поиска)
- **Пример создания**:
```sql
CREATE INDEX idx_documents_content ON documents USING GIN (content);
```

##### GiST (Generalized Search Tree)
- **Описание**: Обобщенное поисковое дерево для геометрических и пользовательских типов данных
- **Подходит для**: Геоданных, полнотекстового поиска
- **Типы данных**: Геометрические типы (point, polygon), tsvector
- **Пример создания**:
```sql
CREATE INDEX idx_locations_position ON locations USING GIST (position);
```

##### BRIN (Block Range Index)
- **Описание**: Индексы для очень больших таблиц с физически упорядоченными данными
- **Подходит для**: Временных рядов, последовательных ID
- **Типы данных**: Числовые, даты, временные метки
- **Пример создания**:
```sql
CREATE INDEX idx_logs_timestamp ON logs USING BRIN (created_at);
```

##### Полнотекстовые индексы
- **Описание**: Специализированные индексы для поиска по тексту
- **Подходит для**: Поиска слов, фраз в текстовых полях
- **Типы данных**: TEXT, VARCHAR
- **Пример создания** (MySQL):
```sql
CREATE FULLTEXT INDEX idx_articles_content ON articles(title, content);
```

##### Составные индексы
- **Описание**: Индексы по нескольким столбцам
- **Подходит для**: Запросов, использующих несколько столбцов в условиях
- **Типы данных**: Любые комбинации поддерживаемых типов
- **Пример создания**:
```sql
CREATE INDEX idx_orders_user_date ON orders(user_id, order_date);
```

#### Преимущества и недостатки индексов

##### Преимущества
- Значительное ускорение запросов на чтение
- Оптимизация сортировки и группировки
- Обеспечение уникальности данных
- Ускорение операций JOIN

##### Недостатки
- Замедление операций вставки, обновления и удаления
- Дополнительное использование дискового пространства
- Необходимость обслуживания (перестроение индексов)
- Не всегда используются оптимизатором запросов

#### Когда создавать индексы
- На столбцах, часто используемых в условиях WHERE
- На столбцах, участвующих в JOIN
- На столбцах, используемых в ORDER BY и GROUP BY
- На столбцах с высокой кардинальностью (много уникальных значений)

#### Когда НЕ создавать индексы
- На маленьких таблицах
- На столбцах с низкой кардинальностью (мало уникальных значений)
- На столбцах, которые редко используются в запросах
- На таблицах с частыми операциями вставки/обновления

#### Почему не стоит индексировать все столбцы

Хотя индексы значительно ускоряют операции чтения, создание индексов для всех столбцов таблицы — плохая практика по следующим причинам:

1. **Увеличение размера базы данных**:
   - Каждый индекс занимает дополнительное дисковое пространство
   - Для больших таблиц индексы могут занимать больше места, чем сами данные

2. **Замедление операций записи**:
   - При каждой вставке, обновлении или удалении данных все индексы должны обновляться
   - Чем больше индексов, тем медленнее выполняются операции изменения данных
   - В системах с интенсивной записью это может привести к серьезному падению производительности

3. **Неэффективное использование памяти**:
   - Индексы загружаются в память для быстрого доступа
   - Избыточные индексы занимают ценное пространство в кэше, которое могло бы использоваться для других данных

4. **Усложнение работы оптимизатора запросов**:
   - Оптимизатор должен анализировать все доступные индексы для выбора оптимального плана
   - Большое количество индексов увеличивает время планирования запросов
   - Иногда оптимизатор может выбрать неоптимальный индекс

5. **Избыточность индексов**:
   - Многие индексы могут дублировать функциональность друг друга
   - Например, составной индекс по (A, B) уже покрывает запросы по столбцу A, делая отдельный индекс по A избыточным

6. **Низкая отдача от индексов на определенных типах столбцов**:
   - Столбцы с низкой кардинальностью (например, пол, статус) дают минимальный прирост производительности
   - Индексы на редко запрашиваемых столбцах не используются, но все равно требуют обслуживания

7. **Сложности при обслуживании базы данных**:
   - Больше индексов = больше времени на обслуживание (перестроение, анализ)
   - Усложняется миграция данных и резервное копирование

**Оптимальный подход**:
- Создавайте индексы только для столбцов, которые часто используются в условиях WHERE, JOIN, ORDER BY, GROUP BY
- Используйте составные индексы для часто встречающихся комбинаций столбцов
- Регулярно анализируйте использование индексов и удаляйте неиспользуемые
- Балансируйте между производительностью чтения и записи в зависимости от характера приложения

#### Управление индексами
```sql
-- Создание индекса
CREATE INDEX idx_users_email ON users(email);

-- Создание уникального индекса
CREATE UNIQUE INDEX idx_users_email_unique ON users(email);

-- Создание составного индекса
CREATE INDEX idx_orders_user_date ON orders(user_id, order_date);

-- Удаление индекса
DROP INDEX idx_users_email;

-- Перестроение индекса (PostgreSQL)
REINDEX INDEX idx_users_email;
```

### EXPLAIN
EXPLAIN — это команда, которая показывает план выполнения запроса, выбранный оптимизатором базы данных. Анализ EXPLAIN помогает понять, как база данных обрабатывает запрос и где могут быть узкие места производительности.

#### Базовый синтаксис
```sql
-- Простой EXPLAIN (показывает только план)
EXPLAIN
SELECT * FROM users WHERE email = 'john@example.com';

-- EXPLAIN ANALYZE (выполняет запрос и показывает реальное время выполнения)
EXPLAIN ANALYZE
SELECT * FROM users WHERE email = 'john@example.com';
```

#### Пример вывода EXPLAIN (PostgreSQL)
```
                                  QUERY PLAN
------------------------------------------------------------------------------
 Index Scan using idx_users_email on users  (cost=0.29..8.31 rows=1 width=72) (actual time=0.039..0.040 rows=1 loops=1)
   Index Cond: (email = 'john@example.com'::text)
 Planning Time: 0.152 ms
 Execution Time: 0.062 ms
```

#### На что обращать внимание при анализе EXPLAIN

1. **Тип операции сканирования**:
   - **Seq Scan** (последовательное сканирование) — просмотр всей таблицы. Может быть проблемой для больших таблиц.
   - **Index Scan** — использование индекса для поиска данных. Обычно эффективнее для выборки небольшого количества строк.
   - **Index Only Scan** — получение данных только из индекса без обращения к таблице. Самый быстрый вариант.
   - **Bitmap Heap/Index Scan** — двухэтапное сканирование для средних объемов данных.

2. **Стоимость (cost)**:
   - Первое число — стоимость запуска (получение первой строки)
   - Второе число — общая стоимость (получение всех строк)
   - Чем меньше, тем лучше

3. **Количество строк (rows)**:
   - Оценка количества строк, которые будут возвращены
   - Большое расхождение между оценкой и фактическим количеством может указывать на устаревшую статистику

4. **Actual time** (в EXPLAIN ANALYZE):
   - Фактическое время выполнения в миллисекундах
   - Помогает выявить медленные операции

5. **Loops**:
   - Количество повторений операции
   - Высокое значение может указывать на неэффективность

6. **Операции соединения (JOIN)**:
   - **Nested Loop** — для небольшого количества строк
   - **Hash Join** — для среднего/большого количества строк, когда одна таблица помещается в память
   - **Merge Join** — для отсортированных данных

7. **Фильтры и условия**:
   - **Filter** — фильтрация после получения строк (менее эффективно)
   - **Index Cond** — фильтрация с использованием индекса (более эффективно)

#### Пример анализа проблемного запроса

```sql
EXPLAIN ANALYZE
SELECT u.name, o.amount 
FROM users u 
JOIN orders o ON u.id = o.user_id 
WHERE u.status = 'active' AND o.created_at > '2023-01-01';
```

Проблемный вывод:
```
                                  QUERY PLAN
------------------------------------------------------------------------------
 Hash Join  (cost=33.38..1342.38 rows=1000 width=40) (actual time=0.388..15.012 rows=1024 loops=1)
   Hash Cond: (o.user_id = u.id)
   ->  Seq Scan on orders o  (cost=0.00..1000.00 rows=5000 width=16) (actual time=0.008..8.312 rows=5000 loops=1)
         Filter: (created_at > '2023-01-01'::date)
         Rows Removed by Filter: 5000
   ->  Hash  (cost=20.88..20.88 rows=1000 width=36) (actual time=0.366..0.366 rows=1000 loops=1)
         Buckets: 1024  Batches: 1  Memory Usage: 53kB
         ->  Seq Scan on users u  (cost=0.00..20.88 rows=1000 width=36) (actual time=0.006..0.201 rows=1000 loops=1)
               Filter: (status = 'active'::text)
               Rows Removed by Filter: 1000
 Planning Time: 0.262 ms
 Execution Time: 15.052 ms
```

Анализ проблем:
1. **Seq Scan on orders** — последовательное сканирование таблицы orders без использования индекса
2. **Seq Scan on users** — последовательное сканирование таблицы users без использования индекса
3. **Rows Removed by Filter** — много строк отфильтровывается после чтения, что неэффективно

Решение:
```sql
-- Создание индексов для оптимизации запроса
CREATE INDEX idx_orders_created_at ON orders(created_at);
CREATE INDEX idx_users_status ON users(status);

-- Повторный запуск EXPLAIN ANALYZE
EXPLAIN ANALYZE
SELECT u.name, o.amount 
FROM users u 
JOIN orders o ON u.id = o.user_id 
WHERE u.status = 'active' AND o.created_at > '2023-01-01';
```

Улучшенный вывод:
```
                                  QUERY PLAN
------------------------------------------------------------------------------
 Hash Join  (cost=21.44..356.44 rows=1000 width=40) (actual time=0.152..1.302 rows=1024 loops=1)
   Hash Cond: (o.user_id = u.id)
   ->  Index Scan using idx_orders_created_at on orders o  (cost=0.29..250.29 rows=5000 width=16) (actual time=0.008..0.782 rows=5000 loops=1)
         Index Cond: (created_at > '2023-01-01'::date)
   ->  Hash  (cost=13.88..13.88 rows=1000 width=36) (actual time=0.131..0.131 rows=1000 loops=1)
         Buckets: 1024  Batches: 1  Memory Usage: 53kB
         ->  Index Scan using idx_users_status on users u  (cost=0.29..13.88 rows=1000 width=36) (actual time=0.011..0.086 rows=1000 loops=1)
               Index Cond: (status = 'active'::text)
 Planning Time: 0.362 ms
 Execution Time: 1.342 ms
```

Результат: время выполнения сократилось с 15.052 мс до 1.342 мс благодаря использованию индексов.

### Оптимизация запросов
1. Использование индексов
2. Избегание SELECT *
3. Оптимизация JOIN
4. Использование LIMIT
5. Кэширование запросов

## Транзакции

### Что такое транзакция
Транзакция — это последовательность операций с базой данных, которая представляет собой логическую единицу работы с данными. Транзакции обеспечивают надежный и последовательный способ внесения изменений в базу данных, даже в случае сбоев системы или конкурентного доступа.

### ACID свойства
- **Atomicity (Атомарность)**: Транзакция выполняется полностью или не выполняется вообще. Если какая-либо часть транзакции не может быть выполнена, вся транзакция отменяется, и база данных возвращается в состояние до начала транзакции.
- **Consistency (Согласованность)**: Транзакция переводит базу данных из одного согласованного состояния в другое. Все ограничения целостности данных (первичные ключи, внешние ключи и т.д.) должны быть соблюдены.
- **Isolation (Изолированность)**: Результаты выполнения транзакции не видны другим транзакциям до её завершения. Это предотвращает чтение промежуточных данных и другие проблемы параллельного доступа.
- **Durability (Долговечность)**: После завершения транзакции изменения сохраняются в базе данных и не могут быть потеряны даже в случае сбоя системы.

### Команды управления транзакциями
```sql
-- Начало транзакции
BEGIN;
-- или
START TRANSACTION;

-- Фиксация изменений
COMMIT;

-- Отмена изменений
ROLLBACK;

-- Создание точки сохранения
SAVEPOINT my_savepoint;

-- Откат до точки сохранения
ROLLBACK TO SAVEPOINT my_savepoint;
```

### Пример транзакции
```sql
BEGIN;
    -- Снятие денег со счета 1
    UPDATE accounts SET balance = balance - 100 WHERE id = 1;

    -- Проверка, что баланс не стал отрицательным
    IF (SELECT balance FROM accounts WHERE id = 1) < 0 THEN
        ROLLBACK;
        RETURN;
    END IF;

    -- Пополнение счета 2
    UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;
```

### Уровни изоляции транзакций
Уровни изоляции определяют, как транзакции взаимодействуют друг с другом при одновременном доступе к данным.

#### 1. READ UNCOMMITTED (Чтение незафиксированных данных)
- Самый низкий уровень изоляции
- Транзакция может видеть незафиксированные изменения других транзакций
- Возможны проблемы: "грязное" чтение, неповторяемое чтение, фантомное чтение
- Пример установки: `SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;`

#### 2. READ COMMITTED (Чтение зафиксированных данных)
- Транзакция видит только зафиксированные изменения других транзакций
- Предотвращает "грязное" чтение
- Возможны проблемы: неповторяемое чтение, фантомное чтение
- Пример установки: `SET TRANSACTION ISOLATION LEVEL READ COMMITTED;`

#### 3. REPEATABLE READ (Повторяемое чтение)
- Гарантирует, что если транзакция дважды прочитала одну и ту же запись, она увидит одинаковые данные
- Предотвращает "грязное" чтение и неповторяемое чтение
- Возможна проблема: фантомное чтение
- Пример установки: `SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;`

#### 4. SERIALIZABLE (Сериализуемость)
- Самый высокий уровень изоляции
- Полная изоляция транзакций, как если бы они выполнялись последовательно
- Предотвращает все проблемы параллельного доступа
- Наименее производительный уровень
- Пример установки: `SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;`

### Проблемы параллельного доступа
- **Грязное чтение (Dirty Read)**: Транзакция читает данные, которые были изменены, но еще не зафиксированы другой транзакцией.
- **Неповторяемое чтение (Non-repeatable Read)**: Транзакция повторно читает данные и обнаруживает, что они были изменены другой зафиксированной транзакцией.
- **Фантомное чтение (Phantom Read)**: Транзакция повторно выполняет запрос и получает другой набор строк из-за вставки или удаления данных другой транзакцией.
- **Потерянное обновление (Lost Update)**: Две транзакции одновременно изменяют одни и те же данные, и одно из изменений "теряется".

## Связи между таблицами

В реляционных базах данных таблицы связываются между собой с помощью ключей. Существует несколько типов связей между таблицами, каждый из которых имеет свои особенности и применение.

### Типы связей

#### Один к одному (One-to-One, 1:1)
- **Описание**: Каждая запись в первой таблице соответствует только одной записи во второй таблице, и наоборот.
- **Пример**: Пользователь и его профиль, сотрудник и его личное дело.
- **Реализация**: Первичный ключ одной таблицы является внешним ключом в другой таблице с ограничением уникальности.
- **Пример SQL**:
```sql
CREATE TABLE users (
    user_id INT PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL
);

CREATE TABLE user_profiles (
    profile_id INT PRIMARY KEY,
    user_id INT UNIQUE,
    bio TEXT,
    avatar_url VARCHAR(255),
    FOREIGN KEY (user_id) REFERENCES users(user_id)
);
```

#### Один ко многим (One-to-Many, 1:N)
- **Описание**: Каждая запись в первой таблице может соответствовать нескольким записям во второй таблице, но каждая запись во второй таблице соответствует только одной записи в первой.
- **Пример**: Отдел и сотрудники, автор и книги, клиент и заказы.
- **Реализация**: Первичный ключ таблицы "один" становится внешним ключом в таблице "многие".
- **Пример SQL**:
```sql
CREATE TABLE departments (
    department_id INT PRIMARY KEY,
    name VARCHAR(100) NOT NULL
);

CREATE TABLE employees (
    employee_id INT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    department_id INT,
    FOREIGN KEY (department_id) REFERENCES departments(department_id)
);
```

#### Многие ко многим (Many-to-Many, N:M)
- **Описание**: Записи в обеих таблицах могут соответствовать нескольким записям в другой таблице.
- **Пример**: Студенты и курсы, товары и заказы, авторы и книги (соавторство).
- **Реализация**: Создается промежуточная таблица (таблица связи), которая содержит внешние ключи на обе связываемые таблицы.
- **Пример SQL**:
```sql
CREATE TABLE students (
    student_id INT PRIMARY KEY,
    name VARCHAR(100) NOT NULL
);

CREATE TABLE courses (
    course_id INT PRIMARY KEY,
    title VARCHAR(100) NOT NULL
);

CREATE TABLE student_courses (
    student_id INT,
    course_id INT,
    enrollment_date DATE,
    PRIMARY KEY (student_id, course_id),
    FOREIGN KEY (student_id) REFERENCES students(student_id),
    FOREIGN KEY (course_id) REFERENCES courses(course_id)
);
```

#### Самоссылающаяся связь (Self-Referencing Relationship)
- **Описание**: Записи в таблице ссылаются на другие записи в той же таблице.
- **Пример**: Иерархия сотрудников (менеджер-подчиненный), категории и подкатегории.
- **Реализация**: Внешний ключ ссылается на первичный ключ той же таблицы.
- **Пример SQL**:
```sql
CREATE TABLE employees (
    employee_id INT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    manager_id INT,
    FOREIGN KEY (manager_id) REFERENCES employees(employee_id)
);
```

### Ограничения целостности

#### Каскадные операции
При работе со связанными таблицами важно определить, что происходит при удалении или обновлении записей:

```sql
CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    customer_id INT,
    order_date DATE,
    FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
    ON DELETE CASCADE -- Удаление клиента приведет к удалению всех его заказов
    ON UPDATE CASCADE -- Обновление ID клиента автоматически обновит ID в заказах
);
```

Варианты действий:
- **CASCADE**: Автоматически удаляет или обновляет связанные записи
- **SET NULL**: Устанавливает NULL в связанных записях
- **SET DEFAULT**: Устанавливает значение по умолчанию
- **RESTRICT**: Запрещает операцию, если есть связанные записи
- **NO ACTION**: Похоже на RESTRICT, но проверка происходит после всех других действий

### Денормализация для оптимизации запросов

Иногда для повышения производительности запросов намеренно нарушают нормализацию, дублируя данные между таблицами:

```sql
-- Нормализованная структура
CREATE TABLE products (
    product_id INT PRIMARY KEY,
    name VARCHAR(100),
    category_id INT,
    FOREIGN KEY (category_id) REFERENCES categories(category_id)
);

-- Денормализованная структура для оптимизации запросов
CREATE TABLE products_denormalized (
    product_id INT PRIMARY KEY,
    name VARCHAR(100),
    category_id INT,
    category_name VARCHAR(100), -- Дублирование данных из таблицы categories
    FOREIGN KEY (category_id) REFERENCES categories(category_id)
);
```

## Нормализация

### 1NF
- Атомарность значений
- Уникальные строки
- Отсутствие повторяющихся групп

### 2NF
- Соответствие 1NF
- Зависимость от полного первичного ключа

### 3NF
- Соответствие 2NF
- Отсутствие транзитивных зависимостей

### Пример нормализации
```sql
-- Денормализованная таблица
CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    customer_name VARCHAR(100),
    product_name VARCHAR(100),
    product_price DECIMAL
);

-- Нормализованные таблицы
CREATE TABLE customers (
    customer_id INT PRIMARY KEY,
    name VARCHAR(100)
);

CREATE TABLE products (
    product_id INT PRIMARY KEY,
    name VARCHAR(100),
    price DECIMAL
);

CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    customer_id INT REFERENCES customers(customer_id),
    product_id INT REFERENCES products(product_id)
);
```

## Вопросы на собеседовании

### Основные концепции SQL

#### Что такое SQL?
SQL (Structured Query Language) — язык структурированных запросов, предназначенный для управления данными в реляционных базах данных. SQL позволяет создавать, изменять, удалять таблицы и другие объекты базы данных, а также выполнять операции с данными.

#### В чем разница между DDL, DML, DCL и TCL?
- **DDL (Data Definition Language)**: Команды для определения структуры базы данных (CREATE, ALTER, DROP, TRUNCATE)
- **DML (Data Manipulation Language)**: Команды для манипуляции данными (SELECT, INSERT, UPDATE, DELETE)
- **DCL (Data Control Language)**: Команды для управления правами доступа (GRANT, REVOKE)
- **TCL (Transaction Control Language)**: Команды для управления транзакциями (COMMIT, ROLLBACK, SAVEPOINT)

#### Что такое первичный ключ и внешний ключ?
- **Первичный ключ (Primary Key)**: Уникальный идентификатор записи в таблице. Не может содержать NULL и должен быть уникальным.
- **Внешний ключ (Foreign Key)**: Поле или набор полей, которые ссылаются на первичный ключ другой таблицы. Используется для установления связей между таблицами.

### Запросы и операции

#### Что такое JOIN и какие типы JOIN существуют?
JOIN — операция, позволяющая объединять строки из двух или более таблиц на основе связанных столбцов. Основные типы:
- **INNER JOIN**: Возвращает строки, когда есть совпадения в обеих таблицах
- **LEFT JOIN**: Возвращает все строки из левой таблицы и совпадающие из правой
- **RIGHT JOIN**: Возвращает все строки из правой таблицы и совпадающие из левой
- **FULL JOIN**: Возвращает строки, когда есть совпадения в одной из таблиц

#### В чем разница между WHERE и HAVING?
- **WHERE**: Фильтрует записи до группировки
- **HAVING**: Фильтрует результаты после группировки (используется с GROUP BY)

#### Что такое подзапросы и когда их использовать?
Подзапрос — это запрос внутри другого запроса. Используются, когда:
- Нужно получить данные на основе результатов другого запроса
- Нужно выполнить сравнение с набором значений
- Нужно проверить существование данных

```sql
SELECT name FROM employees 
WHERE department_id IN (SELECT id FROM departments WHERE location = 'New York');
```

### Индексы и оптимизация

#### Что такое индекс и зачем он нужен?
Индекс — это структура данных, которая улучшает скорость поиска данных в таблице. Индексы ускоряют операции SELECT, но замедляют INSERT, UPDATE и DELETE, так как требуют обновления.

#### Какие типы индексов существуют?
- **B-tree индексы**: Стандартные индексы для большинства операций
- **Hash индексы**: Быстрые для точного соответствия, но не для диапазонов
- **Полнотекстовые индексы**: Для поиска по тексту
- **Пространственные индексы**: Для геоданных

#### Как оптимизировать медленные запросы?
- Использовать индексы для часто запрашиваемых полей
- Избегать SELECT * и выбирать только нужные столбцы
- Использовать EXPLAIN для анализа запросов
- Оптимизировать JOIN (правильный порядок таблиц)
- Избегать функций в WHERE, которые препятствуют использованию индексов

### Транзакции и блокировки

#### Что произойдет, если две транзакции одновременно изменят одни и те же данные?
Зависит от уровня изоляции транзакций:
- При низком уровне изоляции может произойти потерянное обновление
- При высоком уровне одна из транзакций будет ждать завершения другой или получит ошибку

#### Что такое взаимная блокировка (deadlock) и как её избежать?
Взаимная блокировка возникает, когда две транзакции ждут освобождения ресурсов, заблокированных друг другом. Способы избежать:
- Всегда блокировать ресурсы в одинаковом порядке
- Использовать тайм-ауты для транзакций
- Минимизировать время блокировки ресурсов

#### Какой уровень изоляции транзакций следует выбрать для финансовых операций?
Для финансовых операций обычно используют SERIALIZABLE или REPEATABLE READ, чтобы гарантировать целостность данных и избежать аномалий параллельного доступа.

### Нормализация и денормализация

#### Что такое нормализация и зачем она нужна?
Нормализация — процесс организации данных для минимизации избыточности и зависимостей. Помогает:
- Уменьшить дублирование данных
- Предотвратить аномалии обновления
- Упростить запросы

#### Когда следует денормализовать базу данных?
Денормализация может быть полезна, когда:
- Производительность чтения важнее целостности данных
- Запросы слишком сложные из-за множества JOIN
- Нужно оптимизировать часто выполняемые запросы

#### Что такое функциональная зависимость?
Функциональная зависимость означает, что значение одного атрибута однозначно определяет значение другого атрибута. Например, в таблице сотрудников ID сотрудника функционально определяет его имя, зарплату и т.д.

## Репликация баз данных

Репликация — это процесс копирования и синхронизации данных между несколькими базами данных для обеспечения избыточности, повышения доступности и производительности системы.

### Типы репликации

#### 1. Синхронная репликация
- **Описание**: Изменения применяются одновременно на всех узлах. Транзакция считается завершенной только после подтверждения от всех реплик.
- **Преимущества**:
  - Гарантирует полную согласованность данных между всеми узлами
  - Исключает потерю данных при отказе основного сервера
- **Недостатки**:
  - Снижает производительность из-за ожидания подтверждения от всех реплик
  - Высокая чувствительность к задержкам в сети
- **Когда использовать**:
  - Для систем, где целостность данных критически важна (финансовые операции, медицинские данные)
  - В системах с небольшим количеством транзакций и низкими требованиями к скорости

#### 2. Асинхронная репликация
- **Описание**: Изменения сначала применяются на основном сервере, а затем асинхронно передаются на реплики.
- **Преимущества**:
  - Высокая производительность основного сервера
  - Меньшая чувствительность к задержкам в сети
  - Масштабируемость для большого количества реплик
- **Недостатки**:
  - Возможна временная несогласованность данных между серверами
  - Риск потери данных при отказе основного сервера до репликации
- **Когда использовать**:
  - Для систем с высокой нагрузкой на запись
  - Когда допустима небольшая задержка в синхронизации данных
  - Для географически распределенных систем

#### 3. Полусинхронная репликация
- **Описание**: Компромисс между синхронной и асинхронной репликацией. Транзакция считается завершенной после подтверждения от основного сервера и хотя бы одной реплики.
- **Преимущества**:
  - Баланс между производительностью и надежностью
  - Снижение риска потери данных по сравнению с асинхронной репликацией
- **Недостатки**:
  - Все еще возможна несогласованность между некоторыми репликами
  - Сложнее в настройке и управлении
- **Когда использовать**:
  - Для систем, требующих баланса между производительностью и надежностью
  - В кластерах с несколькими узлами, где полная синхронизация затруднительна

### Архитектуры репликации

#### 1. Master-Slave (Primary-Replica)
- **Описание**: Один основной сервер (Master) обрабатывает все операции записи, а один или несколько подчиненных серверов (Slave) получают копии данных и обрабатывают операции чтения.
- **Преимущества**:
  - Простота настройки и управления
  - Хорошая масштабируемость для операций чтения
  - Возможность распределения нагрузки на чтение
- **Недостатки**:
  - Единая точка отказа (Master)
  - Ограниченная масштабируемость для операций записи
  - Необходимость механизма переключения при отказе Master
- **Когда использовать**:
  - Для систем с преобладанием операций чтения над записью
  - Когда требуется простая и надежная архитектура

#### 2. Master-Master (Multi-Master)
- **Описание**: Несколько серверов могут обрабатывать операции записи, и изменения синхронизируются между всеми узлами.
- **Преимущества**:
  - Высокая доступность для операций записи
  - Отсутствие единой точки отказа
  - Географическое распределение операций записи
- **Недостатки**:
  - Сложность разрешения конфликтов при одновременном изменении данных
  - Риск нарушения целостности данных
  - Сложность в настройке и обслуживании
- **Когда использовать**:
  - Для систем, требующих высокой доступности для операций записи
  - Для географически распределенных систем с локальными операциями записи
  - Когда можно эффективно разрешать конфликты данных

#### 3. Кластерная репликация
- **Описание**: Группа серверов работает как единый кластер, автоматически синхронизируя данные и распределяя нагрузку.
- **Преимущества**:
  - Высокая отказоустойчивость
  - Автоматическое восстановление после сбоев
  - Эффективное распределение нагрузки
- **Недостатки**:
  - Высокая сложность настройки и обслуживания
  - Требовательность к сетевой инфраструктуре
  - Потенциальные проблемы с "split-brain" (разделение кластера)
- **Когда использовать**:
  - Для критически важных систем с высокими требованиями к доступности
  - Когда необходима автоматическая отказоустойчивость
  - Для систем с динамически меняющейся нагрузкой

### Специализированные типы репликации

#### 1. Логическая репликация
- **Описание**: Репликация на уровне SQL-запросов или изменений строк, а не на уровне физических файлов данных.
- **Преимущества**:
  - Возможность репликации только части данных
  - Поддержка репликации между разными версиями СУБД
  - Возможность трансформации данных в процессе репликации
- **Недостатки**:
  - Более высокая нагрузка на сервер
  - Сложность в настройке для сложных схем данных
- **Когда использовать**:
  - Для миграции данных между разными версиями СУБД
  - Когда требуется репликация только определенных таблиц или схем
  - Для интеграции с системами ETL и потоковой обработки данных

#### 2. Каскадная репликация
- **Описание**: Реплики могут сами выступать источником для других реплик, образуя иерархическую структуру.
- **Преимущества**:
  - Снижение нагрузки на основной сервер
  - Эффективное географическое распределение
  - Масштабируемость для большого количества реплик
- **Недостатки**:
  - Увеличение задержки репликации для нижних уровней
  - Сложность отслеживания состояния всей системы
- **Когда использовать**:
  - Для географически распределенных систем с большим количеством узлов
  - Когда основной сервер не может обслуживать все реплики напрямую
  - Для создания локальных центров обработки данных

#### 3. Фильтрованная репликация
- **Описание**: Репликация только определенных таблиц, строк или столбцов на основе заданных фильтров.
- **Преимущества**:
  - Экономия ресурсов за счет репликации только необходимых данных
  - Возможность создания специализированных реплик для разных задач
  - Повышение безопасности за счет ограничения доступа к чувствительным данным
- **Недостатки**:
  - Сложность в настройке и поддержке фильтров
  - Потенциальные проблемы с целостностью данных при сложных зависимостях
- **Когда использовать**:
  - Для создания облегченных реплик с подмножеством данных
  - Когда разным группам пользователей нужен доступ к разным данным
  - Для соблюдения требований к локализации и защите данных

### Практические аспекты репликации

#### Мониторинг и обслуживание
- Регулярная проверка задержки репликации
- Мониторинг целостности данных между репликами
- Автоматизация процессов восстановления после сбоев
- Планирование обновлений с минимальным временем простоя

#### Типичные проблемы и их решения
- **Задержка репликации**: Оптимизация сетевого соединения, увеличение пропускной способности, оптимизация запросов
- **Конфликты данных**: Реализация стратегий разрешения конфликтов, временные метки, векторные часы
- **Дрейф схемы**: Координация изменений схемы, использование инструментов миграции
- **Переполнение журналов**: Настройка ротации журналов, мониторинг использования дискового пространства

#### Выбор стратегии репликации
При выборе стратегии репликации следует учитывать:
- Требования к согласованности данных
- Соотношение операций чтения и записи
- Географическое распределение пользователей
- Требования к отказоустойчивости и доступности
- Ограничения сетевой инфраструктуры
- Бюджет и доступные ресурсы
