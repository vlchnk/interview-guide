 # Go (Golang)

## Содержание
1. [Основы языка](#основы-языка)
2. [Конкурентность](#конкурентность)
3. [Работа с памятью](#работа-с-памятью)
4. [Интерфейсы](#интерфейсы)
5. [Обработка ошибок](#обработка-ошибок)
6. [Тестирование](#тестирование)
7. [Стандартная библиотека](#стандартная-библиотека)

## Основы языка
В этом разделе рассматриваются фундаментальные концепции языка Go, которые необходимо знать каждому разработчику.

### Типы данных
Go - статически типизированный язык со строгой типизацией. Это означает, что тип каждой переменной определяется на этапе компиляции и не может быть изменен во время выполнения программы.

```go
// Базовые типы
var (
    i int     = 42      // целочисленный тип (размер зависит от платформы, обычно 32 или 64 бита)
    f float64 = 3.14    // число с плавающей точкой двойной точности (64 бита)
    b bool    = true    // логический тип (true или false)
    s string  = "hello" // строка (неизменяемая последовательность байтов)
)

// Составные типы
type Person struct {     // структура - пользовательский тип, объединяющий несколько полей
    Name string          // поле Name типа string
    Age  int             // поле Age типа int
}

// Массивы и слайсы
var arr [5]int           // массив - фиксированный размер, все элементы одного типа
var slice []int          // слайс - динамический массив, может изменять размер
slice = make([]int, 5)   // инициализация слайса с начальной длиной 5
```

### Управляющие конструкции
Go предлагает простой и лаконичный синтаксис для управления потоком выполнения программы. В отличие от многих других языков, в Go есть только одна конструкция цикла - `for`.

```go
// Условные операторы
if x > 0 {                      // Простое условие, скобки вокруг условия не требуются
    fmt.Println("Positive")
} else if x < 0 {               // Дополнительное условие, проверяется если первое не выполнено
    fmt.Println("Negative")
} else {                        // Выполняется, если ни одно из условий не выполнено
    fmt.Println("Zero")
}

// Циклы
for i := 0; i < 10; i++ {       // Классический цикл с инициализацией, условием и инкрементом
    fmt.Println(i)
}

// Range - специальная форма цикла для итерации по коллекциям
for i, v := range slice {       // Перебирает индексы и значения элементов слайса
    fmt.Printf("Index: %d, Value: %d\n", i, v)
}
```

## Конкурентность
Конкурентность - одна из ключевых особенностей Go, которая позволяет эффективно использовать многоядерные процессоры и создавать высокопроизводительные программы. Go предлагает простые и мощные инструменты для написания конкурентного кода.

### Горутины
Горутины (goroutines) - это легковесные потоки выполнения, управляемые планировщиком Go. Они потребляют гораздо меньше ресурсов, чем системные потоки, что позволяет создавать тысячи горутин в одной программе.

```go
func worker(id int, jobs <-chan int, results chan<- int) {
    for j := range jobs {
        fmt.Printf("worker %d processing job %d\n", id, j)
        time.Sleep(time.Second)
        results <- j * 2
    }
}

func main() {
    jobs := make(chan int, 100)
    results := make(chan int, 100)

    // Запуск воркеров
    for w := 1; w <= 3; w++ {
        go worker(w, jobs, results)
    }

    // Отправка заданий
    for j := 1; j <= 5; j++ {
        jobs <- j
    }
    close(jobs)

    // Получение результатов
    for a := 1; a <= 5; a++ {
        <-results
    }
}
```

### Синхронизация
Для безопасного взаимодействия между горутинами Go предоставляет различные примитивы синхронизации, которые помогают избежать состояний гонки (race conditions) и других проблем многопоточного программирования.

```go
// Mutex
type SafeCounter struct {
    mu sync.Mutex
    v  map[string]int
}

func (c *SafeCounter) Inc(key string) {
    c.mu.Lock()
    c.v[key]++
    c.mu.Unlock()
}

// WaitGroup
func process(items []string) {
    var wg sync.WaitGroup
    for _, item := range items {
        wg.Add(1)
        go func(i string) {
            defer wg.Done()
            // обработка элемента
        }(item)
    }
    wg.Wait()
}
```

## Работа с памятью
Go предоставляет низкоуровневый контроль над памятью через указатели, но при этом обеспечивает безопасность благодаря отсутствию арифметики указателей и автоматическому управлению памятью через сборщик мусора.

### Указатели
Указатели в Go - это переменные, которые хранят адрес другой переменной в памяти. Они позволяют функциям изменять значения переменных, переданных в качестве аргументов, и эффективно работать с большими структурами данных.

```go
func modifyValue(ptr *int) {
    *ptr = 42
}

func main() {
    x := 10
    modifyValue(&x)
    fmt.Println(x) // 42
}
```

### Сборщик мусора

Go использует современный сборщик мусора (Garbage Collector, GC), который автоматически управляет памятью, освобождая разработчиков от необходимости ручного управления памятью.

#### Автоматическое управление памятью
```go
func createObjects() {
    // Память выделяется автоматически
    data := make([]byte, 1024*1024)

    // Когда функция завершается, объекты становятся недоступными
    // и будут собраны сборщиком мусора, когда это необходимо
}

func main() {
    for i := 0; i < 10; i++ {
        createObjects()
        // Нет необходимости вручную освобождать память
    }
}
```

#### Трехцветный алгоритм маркировки
Go использует трехцветный алгоритм маркировки для определения объектов, которые больше не используются:

- **Белые объекты**: потенциальные кандидаты на сборку (не проверенные)
- **Серые объекты**: проверенные, но их ссылки еще не проверены
- **Черные объекты**: проверенные и все их ссылки также проверены

Процесс работы:
1. Все объекты изначально помечаются как белые
2. Корневые объекты (глобальные переменные, стек) помечаются как серые
3. Алгоритм берет серый объект, проверяет все его ссылки, помечает их как серые, а сам объект как черный
4. Процесс повторяется, пока не останется серых объектов
5. Все оставшиеся белые объекты считаются мусором и освобождаются

#### Параллельный сборщик мусора
Сборщик мусора в Go работает параллельно с основной программой:

- **Неблокирующий**: основная программа продолжает выполнение во время сборки мусора
- **Concurrent**: GC работает параллельно с пользовательскими горутинами
- **Stop-the-world (STW) фазы**: минимизированы и обычно занимают менее миллисекунды
- **Инкрементальный**: работает небольшими порциями, а не останавливает всю программу

```go
// Пример запуска принудительной сборки мусора
func main() {
    // Выполнение программы

    // Запуск сборки мусора вручную (обычно не требуется)
    runtime.GC()

    // Продолжение выполнения программы
}
```

#### Настраиваемые параметры GC
Go позволяет настраивать поведение сборщика мусора:

```go
// Установка целевого процента использования CPU для GC
func main() {
    // По умолчанию GOGC=100, что означает запуск GC, когда размер кучи
    // увеличивается на 100% с момента последней сборки

    // Можно установить через переменную окружения
    // export GOGC=50

    // Или программно
    debug.SetGCPercent(50)

    // Получение текущих статистических данных о GC
    var stats runtime.MemStats
    runtime.ReadMemStats(&stats)
    fmt.Printf("GC cycles: %d\n", stats.NumGC)
}
```

Другие настройки:
- `GOGC=off` - отключение автоматической сборки мусора
- `GODEBUG=gctrace=1` - вывод подробной информации о работе GC
- `debug.SetMaxHeap` (Go 1.19+) - установка максимального размера кучи

## Интерфейсы
Интерфейсы в Go - это мощный инструмент для достижения полиморфизма и абстракции. В отличие от других языков, в Go интерфейсы реализуются неявно: тип автоматически удовлетворяет интерфейсу, если реализует все его методы.

### Базовые интерфейсы
Интерфейс определяет набор методов, которые должен реализовать тип, чтобы удовлетворять этому интерфейсу. Это позволяет писать более гибкий и модульный код.

```go
type Shape interface {
    Area() float64
    Perimeter() float64
}

type Rectangle struct {
    Width, Height float64
}

func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}

func (r Rectangle) Perimeter() float64 {
    return 2 * (r.Width + r.Height)
}
```

### Пустой интерфейс
Пустой интерфейс `interface{}` не содержит методов и может хранить значение любого типа. Это аналог `Object` в Java или `any` в TypeScript. Пустой интерфейс часто используется, когда функция должна принимать аргументы разных типов.

```go
func printValue(v interface{}) {
    switch v := v.(type) {
    case int:
        fmt.Printf("Integer: %d\n", v)
    case string:
        fmt.Printf("String: %s\n", v)
    default:
        fmt.Printf("Unknown type: %T\n", v)
    }
}
```

## Обработка ошибок
В Go используется явный подход к обработке ошибок, где ошибки возвращаются как значения, а не выбрасываются как исключения. Это делает код более явным и предсказуемым, так как разработчик должен явно проверять и обрабатывать возможные ошибки.

### Стандартный подход
Стандартный подход к обработке ошибок в Go заключается в возврате ошибки как второго (или последнего) значения из функции. Вызывающий код должен проверить, не является ли ошибка nil, и соответствующим образом обработать её.

```go
func readFile(filename string) ([]byte, error) {
    data, err := ioutil.ReadFile(filename)
    if err != nil {
        return nil, fmt.Errorf("failed to read file: %v", err)
    }
    return data, nil
}

func main() {
    data, err := readFile("example.txt")
    if err != nil {
        log.Fatal(err)
    }
    fmt.Println(string(data))
}
```

### Кастомные ошибки
Для более информативной обработки ошибок в Go можно создавать собственные типы ошибок, реализующие интерфейс `error`. Это позволяет включать дополнительную информацию об ошибке и обрабатывать разные типы ошибок по-разному.

```go
type ValidationError struct {
    Field   string
    Message string
}

func (e *ValidationError) Error() string {
    return fmt.Sprintf("validation error on field %s: %s", e.Field, e.Message)
}

func validateUser(user User) error {
    if user.Name == "" {
        return &ValidationError{Field: "name", Message: "name is required"}
    }
    return nil
}
```

## Тестирование
Go имеет встроенную поддержку тестирования через пакет `testing`. Тесты в Go - это обычные функции, которые следуют определенным соглашениям по именованию и сигнатуре. Тестирование является важной частью разработки на Go, и стандартная библиотека предоставляет все необходимые инструменты.

### Unit тесты
Unit-тесты в Go пишутся в файлах с суффиксом `_test.go` и запускаются командой `go test`. Функции тестирования должны начинаться с префикса `Test` и принимать аргумент типа `*testing.T`.

```go
func TestAdd(t *testing.T) {
    tests := []struct {
        a, b, want int
    }{
        {1, 2, 3},
        {0, 0, 0},
        {-1, 1, 0},
    }

    for _, tt := range tests {
        if got := Add(tt.a, tt.b); got != tt.want {
            t.Errorf("Add(%d, %d) = %d, want %d", tt.a, tt.b, got, tt.want)
        }
    }
}
```

### Benchmark
Бенчмарки (тесты производительности) в Go также являются частью пакета `testing`. Они позволяют измерять производительность кода и сравнивать различные реализации. Функции бенчмарков должны начинаться с префикса `Benchmark` и принимать аргумент типа `*testing.B`.

```go
func BenchmarkFibonacci(b *testing.B) {
    for i := 0; i < b.N; i++ {
        fibonacci(20)
    }
}
```

## Стандартная библиотека
Go поставляется с богатой стандартной библиотекой, которая предоставляет множество пакетов для решения различных задач без необходимости использования сторонних зависимостей. Стандартная библиотека Go хорошо спроектирована, тщательно протестирована и оптимизирована.

### HTTP сервер
Пакет `net/http` предоставляет все необходимое для создания HTTP-клиентов и серверов. С его помощью можно легко создать веб-сервер всего в несколько строк кода.

```go
func handler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "Hello, %s!", r.URL.Path[1:])
}

func main() {
    http.HandleFunc("/", handler)
    log.Fatal(http.ListenAndServe(":8080", nil))
}
```

### JSON
Пакет `encoding/json` предоставляет функции для кодирования и декодирования данных в формате JSON. Go использует теги структур для управления процессом сериализации и десериализации JSON.

```go
type User struct {
    Name  string `json:"name"`
    Email string `json:"email"`
}

func main() {
    // Маршалинг
    user := User{Name: "John", Email: "john@example.com"}
    data, _ := json.Marshal(user)

    // Демаршалинг
    var newUser User
    json.Unmarshal(data, &newUser)
}
```

### Контекст
Пакет `context` предоставляет средства для передачи сроков выполнения, сигналов отмены и других значений, связанных с запросом, между горутинами. Контексты особенно полезны для управления временем жизни операций в распределенных системах и микросервисах.

```go
func process(ctx context.Context) error {
    select {
    case <-ctx.Done():
        return ctx.Err()
    case <-time.After(2 * time.Second):
        return nil
    }
}

func main() {
    ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)
    defer cancel()

    err := process(ctx)
    if err != nil {
        fmt.Println("Error:", err)
    }
}
```
